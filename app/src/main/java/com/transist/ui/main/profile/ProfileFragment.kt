package com.transist.ui.main.profileimport android.animation.Animatorimport android.animation.ValueAnimatorimport android.app.Activityimport android.content.Contextimport android.graphics.Colorimport android.graphics.Rectimport android.os.Bundleimport android.text.Editableimport android.text.InputTypeimport android.text.TextWatcherimport android.util.Logimport android.view.LayoutInflaterimport android.view.Viewimport android.view.ViewGroupimport android.view.ViewTreeObserverimport android.view.inputmethod.InputMethodManagerimport android.widget.AdapterViewimport android.widget.ArrayAdapterimport android.widget.RadioButtonimport android.widget.Spinnerimport android.widget.TextViewimport androidx.appcompat.app.AppCompatDelegateimport androidx.cardview.widget.CardViewimport androidx.core.content.ContextCompatimport androidx.credentials.CredentialManagerimport androidx.credentials.CustomCredentialimport androidx.credentials.GetCredentialRequestimport androidx.fragment.app.Fragmentimport androidx.fragment.app.activityViewModelsimport androidx.lifecycle.Lifecycleimport androidx.lifecycle.ViewModelProviderimport androidx.lifecycle.lifecycleScopeimport androidx.lifecycle.repeatOnLifecycleimport com.android.billingclient.api.AcknowledgePurchaseParamsimport com.android.billingclient.api.BillingClientimport com.android.billingclient.api.BillingClientStateListenerimport com.android.billingclient.api.BillingFlowParamsimport com.android.billingclient.api.BillingResultimport com.android.billingclient.api.PendingPurchasesParamsimport com.android.billingclient.api.Purchaseimport com.android.billingclient.api.QueryProductDetailsParamsimport com.transist.BuildConfigimport com.transist.Rimport com.transist.data.repository.AuthRepositoryimport com.transist.data.repository.LanguageRepositoryimport com.transist.data.repository.PreferencesRepositoryimport com.transist.databinding.FragmentProfileBindingimport com.transist.ui.main.ActivityMainimport com.transist.ui.main.MainViewModelimport com.transist.util.dpToPximport com.transist.util.setSelectionSilentlyimport com.transist.util.showDialogimport com.transist.util.startToastAnimationimport com.transist.util.stopToastAnimationimport com.google.android.libraries.identity.googleid.GetGoogleIdOptionimport com.google.android.libraries.identity.googleid.GoogleIdTokenCredentialimport com.google.android.libraries.identity.googleid.GoogleIdTokenCredential.Companion.TYPE_GOOGLE_ID_TOKEN_CREDENTIALimport com.google.firebase.auth.EmailAuthProviderimport com.google.firebase.auth.FirebaseAuthimport com.google.firebase.auth.GoogleAuthProviderimport com.transist.util.replaceBlanksWithDrawableimport kotlinx.coroutines.launchimport kotlin.math.roundToIntclass ProfileFragment: Fragment() {    private lateinit var activity: Activity    private var _binding: FragmentProfileBinding? = null    private val binding get() = _binding!!  // Null güvenliği için    private lateinit var viewModel: ProfileViewModel    private var directionAnimator: Animator? = null // Hata mesajlarını göstermek için    private val credentialManager by lazy { CredentialManager.create(requireContext()) }    private val mainViewModel: MainViewModel by activityViewModels()    private lateinit var billingClient: BillingClient    private var loginHeight = 0    private var resetHeight = 0    private var registerHeight = 0    override fun onCreateView(        inflater: LayoutInflater,        container: ViewGroup?,        savedInstanceState: Bundle?    ): View {        _binding = FragmentProfileBinding.inflate(inflater, container, false)        // BillingClient oluştur        billingClient = BillingClient.newBuilder(requireContext())            .setListener { billingResult, purchases ->                if (billingResult.responseCode == BillingClient.BillingResponseCode.OK && purchases != null) {                    for (purchase in purchases) handlePurchase(purchase)                }            }            .enablePendingPurchases(PendingPurchasesParams.newBuilder().enableOneTimeProducts().build())            .build()        // Bağlantıyı aç        billingClient.startConnection(object : BillingClientStateListener {            override fun onBillingSetupFinished(result: BillingResult) {                if (result.responseCode == BillingClient.BillingResponseCode.OK) {                    // Bağlantı hazır                    binding.buttonBuy.setOnClickListener { launchSubscriptionFlow() }                }            }            override fun onBillingServiceDisconnected() {                // Yeniden bağlanmayı deneyebilirsin            }        })        return binding.root    }    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {        super.onViewCreated(view, savedInstanceState)        activity = requireActivity() as ActivityMain        val factory = ProfileViewModelFactory(            AuthRepository(FirebaseAuth.getInstance()),            LanguageRepository(requireContext()),            PreferencesRepository(requireContext().applicationContext)        )        viewModel = ViewModelProvider(this, factory).get(ProfileViewModel::class.java)        binding.cvGirisBilgisi.post {            measureCardHeights()        }        setupUI()        observeViewModel()    }    private fun setupUI(){        binding.clMailKayit.visibility = View.GONE        binding.clSifremiUnuttum.visibility = View.GONE        binding.cvToast.visibility = View.GONE        binding.ivTogglePassword.visibility = View.GONE        binding.ivSifreKayit.visibility = View.GONE        mainViewModel.checkSubscription()        if (FirebaseAuth.getInstance().currentUser != null) {            binding.clMailGiris.visibility = View.GONE            binding.clGirisBilgisi.visibility = View.VISIBLE            viewModel.reloadUser()        } else {            binding.clMailGiris.visibility = View.VISIBLE            binding.clGirisBilgisi.visibility = View.GONE        }        binding.ibAktivasyonCheck.setOnClickListener {            viewModel.reloadUser()        }        binding.txtKayitOl.setOnClickListener {            binding.clSifremiUnuttum.visibility = View.GONE            animateCardSwitch(binding.cvGirisBilgisi, binding.clMailGiris, binding.clMailKayit)        }        binding.ibKayitVazgec.setOnClickListener {            binding.clSifremiUnuttum.visibility = View.GONE            animateCardSwitch(binding.cvGirisBilgisi, binding.clMailKayit, binding.clMailGiris)        }        binding.txtSifremiUnuttum.setOnClickListener {            binding.clMailKayit.visibility = View.GONE            animateCardSwitch(binding.cvGirisBilgisi, binding.clMailGiris, binding.clSifremiUnuttum)        }        binding.ibSifirlamaVazgec.setOnClickListener {            binding.clMailKayit.visibility = View.GONE            animateCardSwitch(binding.cvGirisBilgisi, binding.clSifremiUnuttum, binding.clMailGiris)        }        var isPasswordVisible = false        binding.ivTogglePassword.setOnClickListener {            isPasswordVisible = !isPasswordVisible            if (isPasswordVisible) {                binding.etSifre.inputType = InputType.TYPE_TEXT_VARIATION_VISIBLE_PASSWORD                binding.ivTogglePassword.setImageResource(R.drawable.baseline_visibility_24)            } else {                binding.etSifre.inputType = InputType.TYPE_CLASS_TEXT or InputType.TYPE_TEXT_VARIATION_PASSWORD                binding.ivTogglePassword.setImageResource(R.drawable.baseline_visibility_off_24)            }            // Cursor'u en sona almak için:            binding.etSifre.setSelection(binding.etSifre.text.length)        }        var isPasswordVisible2 = false        binding.ivSifreKayit.setOnClickListener {            isPasswordVisible2 = !isPasswordVisible2            if (isPasswordVisible2) {                binding.etSifreKayit.inputType = InputType.TYPE_TEXT_VARIATION_VISIBLE_PASSWORD                binding.ivSifreKayit.setImageResource(R.drawable.baseline_visibility_24)            } else {                binding.etSifreKayit.inputType = InputType.TYPE_CLASS_TEXT or InputType.TYPE_TEXT_VARIATION_PASSWORD                binding.ivSifreKayit.setImageResource(R.drawable.baseline_visibility_off_24)            }            // Cursor'u en sona almak için:            binding.etSifreKayit.setSelection(binding.etSifreKayit.text.length)        }        binding.etSifre.addTextChangedListener(object : TextWatcher {            override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {}            override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {}            override fun afterTextChanged(s: Editable?) {                if (s.isNullOrEmpty()) {                    binding.ivTogglePassword.visibility = View.GONE                } else {                    binding.ivTogglePassword.visibility = View.VISIBLE                }            }        })        binding.etSifreKayit.addTextChangedListener(object : TextWatcher {            override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {}            override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {}            override fun afterTextChanged(s: Editable?) {                if (s.isNullOrEmpty()) {                    binding.ivSifreKayit.visibility = View.GONE                } else {                    binding.ivSifreKayit.visibility = View.VISIBLE                }            }        })        // Spinner setup        val languageList = viewModel.getListOfLanguages()        val languageListInNative = viewModel.getLanguageListInNative(languageList)        val userLangs = viewModel.userLanguages.value ?: Pair("un", "un")        var nativeLanguageCode = userLangs.first        var targetLanguageCode = userLangs.second        val nativeIndex = languageList.indexOfFirst { it.code == nativeLanguageCode }        val targetIndex = languageList.indexOfFirst { it.code == targetLanguageCode }        val unKnownIndex = languageList.indexOfFirst { it.code == "un" }        val adapterSpinner = object: ArrayAdapter<String>(requireContext(), R.layout.spinner_item_layout, languageListInNative)        {            override fun getView(position: Int, convertView: View?, parent: ViewGroup): View {                val view = super.getView(position, convertView, parent) as TextView                val spinner = parent as Spinner   // hangi spinner için çağrıldıysa o                val selectedPos = spinner.selectedItemPosition                if (position == selectedPos) {                    if (selectedPos == unKnownIndex) {                        view.setTextColor(Color.RED) // index "un" seçiliyse kırmızı                    } else {                        view.setTextColor(ContextCompat.getColor(requireContext(), R.color.textColorPrimary))   // diğer seçili indexler siyah                    }                }                return view            }            override fun getDropDownView(position: Int, convertView: View?, parent: ViewGroup): View {                val view = super.getDropDownView(position, convertView, parent) as TextView                view.setTextColor(ContextCompat.getColor(requireContext(), R.color.textColorPrimary)) // dropdown’daki tüm elemanlar siyah                return view            }        }        adapterSpinner.setDropDownViewResource(R.layout.spinner_item_layout)        binding.spinnerAnadil.adapter = adapterSpinner        binding.spinnerHedefDil.adapter = adapterSpinner        // Spinner listener        val nativeSpinnerListener = object : AdapterView.OnItemSelectedListener {            override fun onItemSelected(parent: AdapterView<*>?, view: View?, position: Int, id: Long) {                val selectedCode = languageList[position].code                nativeLanguageCode = selectedCode                if (selectedCode.equals(targetLanguageCode)){                    targetLanguageCode = "un"                    binding.spinnerHedefDil.setSelectionSilently(unKnownIndex)                }                mainViewModel.updateUserLanguageCodes(selectedCode, targetLanguageCode)                removeStudyFolderFragment()            }            override fun onNothingSelected(parent: AdapterView<*>?) {}        }        val targetSpinnerListener = object : AdapterView.OnItemSelectedListener {            override fun onItemSelected(parent: AdapterView<*>?, view: View?, position: Int, id: Long) {                val selectedCode = languageList[position].code                targetLanguageCode = selectedCode                if (selectedCode.equals(nativeLanguageCode)){                    nativeLanguageCode = "un"                    binding.spinnerAnadil.setSelectionSilently(unKnownIndex)                }                mainViewModel.updateUserLanguageCodes(nativeLanguageCode, selectedCode)                removeStudyFolderFragment()            }            override fun onNothingSelected(parent: AdapterView<*>?) {}        }        binding.spinnerAnadil.onItemSelectedListener = nativeSpinnerListener        binding.spinnerHedefDil.onItemSelectedListener = targetSpinnerListener        binding.spinnerAnadil.setSelectionSilently(nativeIndex)        binding.spinnerHedefDil.setSelectionSilently(targetIndex)        binding.txtAktivasyon.setOnClickListener {            viewModel.sendEmailVerification()        }        binding.ibCikis.setOnClickListener {            val d = showDialog(R.layout.dialog_exit, activity, false)            val tvExit = d.first.findViewById<TextView>(R.id.tv_exit)            tvExit.setOnClickListener {                viewModel.signOut()                binding.clMailGiris.visibility = View.VISIBLE                binding.clGirisBilgisi.visibility = View.GONE                d.second.cancel()            }        }        // Button listeners        binding.butonKayit.setOnClickListener {            val email = binding.etMailKayit.text.toString()            val password = binding.etSifreKayit.text.toString()            if (email.isNotEmpty() && password.isNotEmpty()) viewModel.signUp(email, password)            else makeToast(getString(R.string.warn_missing_input))        }        binding.ibPasswordHint.setOnClickListener {            showDialog(R.layout.dialog_password_criteria, activity, false)        }        binding.butonGiris.setOnClickListener {            val email = binding.etMail.text.toString()            val password = binding.etSifre.text.toString()            if (email.isNotEmpty() && password.isNotEmpty()) {                viewModel.signIn(email, password)            }            else makeToast(getString(R.string.warn_missing_input))        }        binding.logInGoogle.setOnClickListener {            lifecycleScope.launch {                try {                    val googleIdOption = GetGoogleIdOption.Builder()                        .setServerClientId(getString(R.string.default_web_client_id))                        .setFilterByAuthorizedAccounts(false)                        .build()                    val request = GetCredentialRequest.Builder()                        .addCredentialOption(googleIdOption)                        .build()                    val credential = credentialManager.getCredential(requireContext(), request).credential                    if (credential is CustomCredential && credential.type == TYPE_GOOGLE_ID_TOKEN_CREDENTIAL) {                        val googleIdTokenCredential = GoogleIdTokenCredential.createFrom(credential.data)                        val googleCredential = GoogleAuthProvider.getCredential(googleIdTokenCredential.idToken, null)                        viewModel.signInWithGoogleCredential(googleCredential)                    } else {                        Log.e("FAILED", "Credential is not of type Google ID!")                        makeToast(getString(R.string.error_occured))                    }                } catch (e: Exception) {                    Log.d("FAILED", "Google Sign-In failed: ${e.message}")                    if (e.message != "activity is cancelled by the user."){                        makeToast(getString(R.string.error_occured))                    }                }            }        }        binding.butonSifirla.setOnClickListener {            val email = binding.etMailSifremiUnuttum.text.toString()            if (email.isNotEmpty()) {                viewModel.sendPasswordResetEmail(email)            } else {                makeToast(getString(R.string.warn_missing_input))            }        }        binding.ibLight.setOnClickListener {            val d = showDialog(R.layout.dialog_choose_theme, activity, false)            val rbSystemDefault = d.first.findViewById<RadioButton>(R.id.rb_system_default)            val rbLight = d.first.findViewById<RadioButton>(R.id.rb_light)            val rbDark = d.first.findViewById<RadioButton>(R.id.rb_dark)            val tvCancel = d.first.findViewById<TextView>(R.id.tv_cancel)            val tvOk = d.first.findViewById<TextView>(R.id.tv_ok)            rbSystemDefault.isChecked = false            rbDark.isChecked = false            rbLight.isChecked = false            rbSystemDefault.setOnClickListener {                rbDark.isChecked = false                rbLight.isChecked = false            }            rbLight.setOnClickListener {                rbDark.isChecked = false                rbSystemDefault.isChecked = false            }            rbDark.setOnClickListener {                rbSystemDefault.isChecked = false                rbLight.isChecked = false            }            // Kayıtlı ayarı al.            when (viewModel.getThemeMode()) {                AppCompatDelegate.MODE_NIGHT_FOLLOW_SYSTEM -> rbSystemDefault.isChecked = true                AppCompatDelegate.MODE_NIGHT_NO -> rbLight.isChecked = true                AppCompatDelegate.MODE_NIGHT_YES -> rbDark.isChecked = true            }            // Değişikliği kaydet.            tvOk.setOnClickListener {                when {                    rbSystemDefault.isChecked -> viewModel.setThemeMode(AppCompatDelegate.MODE_NIGHT_FOLLOW_SYSTEM)                    rbLight.isChecked -> viewModel.setThemeMode(AppCompatDelegate.MODE_NIGHT_NO)                    rbDark.isChecked -> viewModel.setThemeMode(AppCompatDelegate.MODE_NIGHT_YES)                }                d.second.cancel()            }            tvCancel.setOnClickListener { d.second.cancel() }        }        binding.txtHesapSil.setOnClickListener {            val d = showDialog(R.layout.dialog_delete_account, activity, false)            val tvDelete = d.first.findViewById<TextView>(R.id.tv_delete_btn)            tvDelete.setOnClickListener {                viewModel.tryDeleteUser()                d.second.cancel()            }        }    }    private fun observeViewModel(){        lifecycleScope.launch {            repeatOnLifecycle(Lifecycle.State.STARTED) {                mainViewModel.isSubscribed.collect { isSubscribed ->                    if (!isSubscribed.first){                        binding.txtAbonelikSuresi.visibility = View.GONE                        binding.txtRemainingTranslationCount.visibility = View.VISIBLE                        binding.buttonBuy.visibility = View.VISIBLE                    } else {                        binding.txtAbonelikSuresi.visibility = View.VISIBLE                        binding.txtRemainingTranslationCount.visibility = View.GONE                        binding.buttonBuy.visibility = View.GONE                    }                }            }        }        viewModel.emailVerificationResult.observe(viewLifecycleOwner) { result ->            result.onSuccess {                showDialog(R.layout.dialog_aktivasyon_mail, activity, false)            }.onFailure { e ->                showDialog(R.layout.dialog_aktivasyon_basarisiz, activity, false)                Log.e("EmailVerification", "Hata: ${e.message}")            }        }        viewModel.signedOut.observe(viewLifecycleOwner) { signedOut ->            if (signedOut) {                binding.clMailGiris.visibility = View.VISIBLE                binding.clGirisBilgisi.visibility = View.GONE            }        }        viewModel.signUpResult.observe(viewLifecycleOwner) { result ->            result.onSuccess {                viewModel.sendEmailVerification()                binding.clGirisBilgisi.visibility = View.VISIBLE                binding.clMailKayit.visibility = View.GONE                binding.etMailKayit.setText("")                binding.etSifreKayit.setText("")            }.onFailure { exception ->                val errorCode = exception.message                if (BuildConfig.DEBUG) Log.e("hata", "Kayıt hatası: $errorCode")                val messageResId = when (errorCode) {                    "ERROR_EMAIL_ALREADY_IN_USE" -> R.string.error_email_already_in_use                    "ERROR_INVALID_EMAIL" -> R.string.error_invalid_email                    "ERROR_WEAK_PASSWORD" -> R.string.error_weak_password                    "ERROR_INVALID_PASSWORD" -> R.string.error_invalid_password                    else -> R.string.error_unknown                }                makeToast(getString(messageResId))            }        }        viewModel.signInResult.observe(viewLifecycleOwner) { result ->            result.onSuccess {                hideKeyboard(binding.butonGiris)                binding.etMail.setText("")                binding.etSifre.setText("")                val params = binding.cvGirisBilgisi.layoutParams                params.height = ViewGroup.LayoutParams.WRAP_CONTENT                binding.cvGirisBilgisi.layoutParams = params                binding.clGirisBilgisi.visibility = View.VISIBLE                binding.clMailGiris.visibility = View.GONE                viewModel.reloadUser() // Bu fonksiyon hâlâ View tarafında kalabilir            }.onFailure { e ->                makeToast(getString(R.string.log_in_failed))            }        }        viewModel.googleSignInResult.observe(viewLifecycleOwner) { result ->            result.onSuccess {                binding.etMail.setText("")                binding.etSifre.setText("")                val params = binding.cvGirisBilgisi.layoutParams                params.height = ViewGroup.LayoutParams.WRAP_CONTENT                binding.cvGirisBilgisi.layoutParams = params                binding.clGirisBilgisi.visibility = View.VISIBLE                binding.clMailGiris.visibility = View.GONE                viewModel.reloadUser()            }.onFailure {                makeToast(getString(R.string.error_occured))            }        }        viewModel.passwordResetResult.observe(viewLifecycleOwner) { result ->            result.onSuccess {                binding.clMailGiris.visibility = View.VISIBLE                binding.logInGoogle.visibility = View.VISIBLE                binding.clMailKayit.visibility = View.GONE                binding.clSifremiUnuttum.visibility = View.GONE                showDialog(R.layout.dialog_sifirlama_bilgi, activity, false)                binding.etMailSifremiUnuttum.text?.clear()            }.onFailure { e ->                makeToast(getString(R.string.error_occured))            }        }        viewModel.deleteUserState.observe(viewLifecycleOwner) { state ->            when (state) {                is DeleteUserState.Success -> {                    Log.d("Firebase", "Kullanıcı silindi.")                    binding.clGirisBilgisi.visibility = View.GONE                    binding.clMailGiris.visibility = View.VISIBLE                }                is DeleteUserState.ReauthRequired -> {                    showDialog(R.layout.dialog_delete_error, activity, false)                }                is DeleteUserState.Error -> {                    Log.e("Firebase", "Silme hatası: ${state.message}")                }            }        }        viewModel.isLoading.observe(viewLifecycleOwner) { loading ->            if (loading) {                binding.txtGirisBilgisi.visibility = View.GONE                binding.ibAktivasyonCheck.visibility = View.GONE                binding.txtAktivasyon.visibility = View.GONE                binding.txtSifreDeIstir.visibility = View.GONE                binding.txtHesapSil.visibility = View.GONE                binding.progressBarGirisBilgisi.visibility = View.VISIBLE            } else {                // yükleme bittiğinde progress gizle (detaylı UI güncellemesi currentUser observer'ında yapılacak)                binding.progressBarGirisBilgisi.visibility = View.GONE            }        }        viewModel.currentUser.observe(viewLifecycleOwner) { user ->            if (user != null) {                binding.clMailGiris.visibility = View.GONE                binding.clGirisBilgisi.visibility = View.VISIBLE                val providerId = user.providerData.lastOrNull()?.providerId                val email = user.email ?: user.providerData.firstOrNull { it.email != null }?.email ?: "Bilinmeyen e-posta"                binding.txtGirisBilgisi.text = when (providerId) {                    GoogleAuthProvider.PROVIDER_ID -> getString(R.string.txt_giris_bilgisi_google).replace("xxx", email)                    EmailAuthProvider.PROVIDER_ID -> getString(R.string.txt_giris_bilgisi_email).replace("xxx", email)                    else -> "Bilinmeyen bir yöntemle giriş yaptınız."                }                binding.txtGirisBilgisi.visibility = View.VISIBLE                binding.txtHesapSil.visibility = View.VISIBLE                binding.progressBarGirisBilgisi.visibility = View.GONE                // Email doğrulama görünürlüğü                if (providerId == EmailAuthProvider.PROVIDER_ID) {                    binding.txtSifreDeIstir.visibility = View.VISIBLE                    val isVerified = user.isEmailVerified                    binding.txtAktivasyon.visibility = if (isVerified) View.GONE else View.VISIBLE                    binding.ibAktivasyonCheck.visibility = if (isVerified) View.GONE else View.VISIBLE                } else {                    binding.txtAktivasyon.visibility = View.GONE                    binding.ibAktivasyonCheck.visibility = View.GONE                    binding.txtSifreDeIstir.visibility = View.GONE                }                binding.txtSifreDeIstir.setOnClickListener{                    viewModel.resetPassword(email)                }            } else {                binding.clMailGiris.visibility = View.VISIBLE                binding.clGirisBilgisi.visibility = View.GONE            }        }        viewModel.resetPasswordResult.observe(viewLifecycleOwner) { success ->            if (success) {                showDialog(R.layout.dialog_sifre_sifirlama, activity, false)            } else {                showDialog(R.layout.dialog_sifirlama_basarisiz, activity, false)            }        }        mainViewModel.translation_count.observe(viewLifecycleOwner) { count ->            binding.txtRemainingTranslationCount.text = getString(R.string.txt_remaining_translation_count, count.toString())        }    }    private val keyboardListener = ViewTreeObserver.OnGlobalLayoutListener {        val binding = _binding ?: return@OnGlobalLayoutListener        val rect = Rect()        binding.root.getWindowVisibleDisplayFrame(rect)        val screenHeight = binding.root.height        val keyboardHeight = screenHeight - rect.height()        val isKeyboardVisible = keyboardHeight > screenHeight * 0.15        val layoutParams = binding.scrollView.layoutParams as ViewGroup.MarginLayoutParams        if (isKeyboardVisible && layoutParams.bottomMargin != keyboardHeight) {            layoutParams.bottomMargin = keyboardHeight            binding.scrollView.layoutParams = layoutParams        }        if (!isKeyboardVisible && layoutParams.bottomMargin != dpToPx(50).roundToInt()){            layoutParams.bottomMargin = dpToPx(50).roundToInt()            binding.scrollView.layoutParams = layoutParams        }    }    override fun onHiddenChanged(hidden: Boolean) {        super.onHiddenChanged(hidden)        _binding?.let { binding ->            if (hidden) {                // Fragment gizlendiğinde yapılacak işlemler                binding.root.viewTreeObserver.removeOnGlobalLayoutListener(keyboardListener)            } else {                // Fragment görünür olduğunda yapılacak işlemler                binding.root.viewTreeObserver.addOnGlobalLayoutListener(keyboardListener)                mainViewModel.checkAndResetDailyQuota()                mainViewModel.checkSubscription()            }        }    }    override fun onDestroyView() {        binding.root.viewTreeObserver.removeOnGlobalLayoutListener(keyboardListener)        super.onDestroyView()        _binding = null  // Hafıza sızıntısını önlemek için    }    fun hideKeyboard(view: View) {        val imm = view.context.getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager        imm.hideSoftInputFromWindow(view.windowToken, 0)    }    private fun makeToast(s: String){        binding.tvToast.setText(s)        stopToastAnimation(directionAnimator)        directionAnimator = startToastAnimation(binding.cvToast)    }    private fun removeStudyFolderFragment(){        val studyFolderFragment = parentFragmentManager.findFragmentByTag("studyFolder")        if (studyFolderFragment != null) {            parentFragmentManager.beginTransaction()                .remove(studyFolderFragment)                .commit()        }    }    private fun measureCardHeights() {        val layouts = listOf(binding.clMailGiris, binding.clMailKayit, binding.clSifremiUnuttum)        // CardView genişliği hazır değilse ekran genişliğini kullan        val screenWidth = resources.displayMetrics.widthPixels        val cardWidth = binding.cvGirisBilgisi.width.takeIf { it > 0 } ?: screenWidth        val widthSpec = View.MeasureSpec.makeMeasureSpec(cardWidth, View.MeasureSpec.EXACTLY)        val heightSpec = View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED)        // Mevcut görünürlükleri kaydet, sonra geri yükleyeceğiz        val originalVisibilities = layouts.map { it.visibility }        layouts.forEach { layout ->            layout.visibility = View.INVISIBLE            layout.measure(widthSpec, heightSpec)            when (layout.id) {                R.id.cl_mail_giris -> loginHeight = layout.measuredHeight                R.id.cl_sifremi_unuttum -> resetHeight = layout.measuredHeight                R.id.cl_mail_kayit -> registerHeight = layout.measuredHeight            }        }        // Eski görünürlükleri geri getir        layouts.forEachIndexed { index, layout ->            layout.visibility = originalVisibilities[index]        }    }    private fun animateCardSwitch(cardView: CardView, currentLayout: View, nextLayout: View) {        val duration = 500L        val half = duration / 2        val startHeight = currentLayout.height.takeIf { it > 0 } ?: when (currentLayout.id) {            R.id.cl_mail_giris -> loginHeight            R.id.cl_sifremi_unuttum -> resetHeight            R.id.cl_mail_kayit -> registerHeight            else -> cardView.height        }        val endHeight = when (nextLayout.id) {            R.id.cl_mail_giris -> loginHeight            R.id.cl_sifremi_unuttum -> resetHeight            R.id.cl_mail_kayit -> registerHeight            else -> startHeight        }        // Height animator        val heightAnimator = ValueAnimator.ofInt(startHeight, endHeight).apply {            this.duration = duration            addUpdateListener { anim ->                val newH = anim.animatedValue as Int                val lp = cardView.layoutParams                lp.height = newH                cardView.layoutParams = lp            }        }        // İçerik animasyonu: önce mevcut fade out (first half)        currentLayout.animate()            .alpha(0f)            .setDuration(half)            .withEndAction {                currentLayout.visibility = View.GONE            }            .start()        // ikinci yarıda yeni layout görünür ve fade in olur        cardView.postDelayed({            nextLayout.alpha = 0f            nextLayout.visibility = View.VISIBLE            nextLayout.animate()                .alpha(1f)                .setDuration(half)                .start()        }, half)        heightAnimator.start()    }    private fun launchSubscriptionFlow() {        val productList = listOf(            QueryProductDetailsParams.Product.newBuilder()                .setProductId("transist_subscription_monthly") // Play Console’daki ürün kimliği                .setProductType(BillingClient.ProductType.SUBS)                .build()        )        val params = QueryProductDetailsParams.newBuilder()            .setProductList(productList)            .build()        billingClient.queryProductDetailsAsync(params) { _, productDetailsList ->            val productDetails = productDetailsList.productDetailsList.firstOrNull() ?: return@queryProductDetailsAsync            val offerToken = productDetails.subscriptionOfferDetails?.firstOrNull()?.offerToken ?: return@queryProductDetailsAsync            val flowParams = BillingFlowParams.newBuilder()                .setProductDetailsParamsList(                    listOf(                        BillingFlowParams.ProductDetailsParams.newBuilder()                            .setProductDetails(productDetails)                            .setOfferToken(offerToken)                            .build()                    )                )                .build()            billingClient.launchBillingFlow(requireActivity(), flowParams)        }    }    private fun handlePurchase(purchase: Purchase) {        if (purchase.purchaseState == Purchase.PurchaseState.PURCHASED) {            // Backend'e doğrulama gönder            // acknowledge işlemi yapılmazsa 3 gün sonra iptal olur            val params = AcknowledgePurchaseParams.newBuilder()                .setPurchaseToken(purchase.purchaseToken)                .build()            billingClient.acknowledgePurchase(params) { result ->                if (result.responseCode == BillingClient.BillingResponseCode.OK) {                    makeToast("The subscription has been activated.")                }            }        }    }}